package cdx

import (
	"bytes"
	"errors"
	"fmt"
	"math"
	"os"
	"reflect"
	"strings"

	cdx "github.com/CycloneDX/cyclonedx-go"
	"github.com/lee-preimesberger/sbom-scorecard/pkg/scorecard"
)

type CycloneDXReport struct {
	valid    bool
	docError error

	creationToolName     int
	creationToolVersion  int
	hasCreationTimestamp bool

	totalPackages  int
	hasLicense     int
	hasPackVersion int
	hasPackDigest  int
	hasPurl        int
	hasCPE         int
	hasPurlOrCPE   int
}

func (r *CycloneDXReport) Metadata() scorecard.ReportMetadata {
	return scorecard.ReportMetadata{
		TotalPackages: r.totalPackages,
	}
}

var missingPackages = scorecard.ReportValue{
	Ratio:     0,
	Reasoning: "No packages",
}

func (r *CycloneDXReport) Report() string {
	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("%d total packages\n", r.totalPackages))

	sb.WriteString(fmt.Sprintf("%d%% have versions.\n", scorecard.PrettyPercent(r.hasPackVersion, r.totalPackages)))
	sb.WriteString(fmt.Sprintf("%d%% have licenses.\n", scorecard.PrettyPercent(r.hasLicense, r.totalPackages)))
	sb.WriteString(fmt.Sprintf("%d%% have package digest.\n", scorecard.PrettyPercent(r.hasPackDigest, r.totalPackages)))
	sb.WriteString(fmt.Sprintf("%d%% have purls.\n", scorecard.PrettyPercent(r.hasPurl, r.totalPackages)))
	sb.WriteString(fmt.Sprintf("%d%% have CPEs.\n", scorecard.PrettyPercent(r.hasCPE, r.totalPackages)))

	sb.WriteString(fmt.Sprintf("Has creation info? %v\n", r.hasCreationInfo()))
	sb.WriteString(fmt.Sprintf("Spec valid? %v\n", r.valid))
	return sb.String()
}

func (r *CycloneDXReport) hasCreationInfo() bool {
	return r.creationToolName > 0 &&
		r.creationToolVersion > 0 &&
		r.creationToolName == r.creationToolVersion
}

func (r *CycloneDXReport) IsSpecCompliant() scorecard.ReportValue {
	if !r.valid {
		return scorecard.ReportValue{
			Ratio:     0,
			Reasoning: "Couldn't parse the SBOM",
		}
	}

	if r.docError != nil {
		return scorecard.ReportValue{
			Ratio:     0,
			Reasoning: r.docError.Error(),
		}
	}
	return scorecard.ReportValue{Ratio: 1}
}

func (r *CycloneDXReport) PackageIdentification() scorecard.ReportValue {
	if r.totalPackages == 0 {
		return missingPackages
	}
	purlPercent := scorecard.PrettyPercent(r.hasPurl, r.totalPackages)
	cpePercent := scorecard.PrettyPercent(r.hasCPE, r.totalPackages)
	either := scorecard.PrettyPercent(r.hasPurlOrCPE, r.totalPackages)
	return scorecard.ReportValue{
		// What percentage has both Purl or CPEs?
		Ratio:     nanToZero(float32(r.hasPurlOrCPE) / float32(r.totalPackages)),
		Reasoning: fmt.Sprintf("%d%% have either a purl (%d%%) or CPE (%d%%)", either, purlPercent, cpePercent),
	}
}

func (r *CycloneDXReport) PackageVersions() scorecard.ReportValue {
	return scorecard.ReportValue{
		Ratio: nanToZero(float32(r.hasPackVersion) / float32(r.totalPackages)),
	}
}

func (r *CycloneDXReport) PackageDigests() scorecard.ReportValue {
	return scorecard.ReportValue{
		Ratio: nanToZero(float32(r.hasPackDigest) / float32(r.totalPackages)),
	}
}

func (r *CycloneDXReport) PackageLicenses() scorecard.ReportValue {
	return scorecard.ReportValue{
		Ratio: nanToZero(float32(r.hasLicense) / float32(r.totalPackages)),
	}
}

func (r *CycloneDXReport) CreationInfo() scorecard.ReportValue {
	var score float32
	score = 1.0
	var reasoning []string

	if r.creationToolName == 0 {
		return scorecard.ReportValue{
			Ratio:     0,
			Reasoning: "SBOM was not generated by a tool",
		}
	}

	if r.creationToolVersion == 0 {
		score -= .2
		reasoning = append(reasoning, "Creation tool does not list a version")

	}

	if !r.hasCreationTimestamp {
		score -= .2
		reasoning = append(reasoning, "Missing creation timestamp")
	}

	return scorecard.ReportValue{
		Ratio:     score,
		Reasoning: strings.Join(reasoning, ", "),
	}
}

func nanToZero(f float32) float32 {
	if math.IsNaN(float64(f)) {
		return 0
	}
	return f
}

func GetCycloneDXReport(filename string) scorecard.SbomReport {
	contents, err := os.ReadFile(filename)
	if err != nil {
		fmt.Printf("Error while opening %v for reading: %v", filename, err)
		return nil
	}

	r := CycloneDXReport{}
	formats := []cdx.BOMFileFormat{cdx.BOMFileFormatJSON, cdx.BOMFileFormatXML}

	sentinelBom := new(cdx.BOM)
	bom := new(cdx.BOM)
	for _, format := range formats {
		decoder := cdx.NewBOMDecoder(bytes.NewReader(contents), format)
		if err = decoder.Decode(bom); err != nil {
			r.valid = false
			r.docError = err
		} else if reflect.DeepEqual(bom, sentinelBom) {
			// If the bom was "decoded" but no fields made it over, it's not valid.
			r.valid = false
			r.docError = errors.New("SBOM decoded, but no fields were parsed.")
		} else {
			r.valid = true
			r.docError = nil
			break
		}
	}

	if !r.valid {
		return &r
	}

	if bom.Metadata != nil && bom.Metadata.Tools != nil {
		for _, t := range *bom.Metadata.Tools {
			if t.Name != "" {
				r.creationToolName += 1
			}
			if t.Version != "" {
				r.creationToolVersion += 1
			}
		}
	}

	if bom.Metadata.Timestamp != "" {
		r.hasCreationTimestamp = true
	}

	if bom.Components != nil {
		for _, p := range *bom.Components {
			r.totalPackages += 1
			if p.Licenses != nil && len(*p.Licenses) > 0 {
				r.hasLicense += 1
			}
			if p.Hashes != nil && len(*p.Hashes) > 0 {
				r.hasPackDigest += 1
			}
			if p.Version != "" {
				r.hasPackVersion += 1
			}
			if p.PackageURL != "" {
				r.hasPurl += 1
			}
			if p.CPE != "" {
				r.hasCPE += 1
			}
			if p.PackageURL != "" || p.CPE != "" {
				r.hasPurlOrCPE += 1
			}
		}
	}

	return &r
}
